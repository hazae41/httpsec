(()=>{"use strict";var __webpack_modules__={"./src/libs/split/index.ts":(module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   splitAndJoin: () => (/* binding */ splitAndJoin)\n/* harmony export */ });\nfunction splitAndJoin(text, separator) {\n    const [first, ...rest] = text.split(separator);\n    const join = rest.join(separator);\n    return [\n        first,\n        join\n    ];\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGlicy9zcGxpdC9pbmRleC50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sU0FBU0EsYUFBYUMsSUFBWSxFQUFFQyxTQUFpQjtJQUMxRCxNQUFNLENBQUNDLE9BQU8sR0FBR0MsS0FBSyxHQUFHSCxLQUFLSSxLQUFLLENBQUNIO0lBRXBDLE1BQU1JLE9BQU9GLEtBQUtFLElBQUksQ0FBQ0o7SUFFdkIsT0FBTztRQUFDQztRQUFPRztLQUFLO0FBQ3RCIiwic291cmNlcyI6WyIvVXNlcnMvaHVnby9Mb2NhbC9UcmF2YWlsL2h0dHBzZWMvc3JjL2xpYnMvc3BsaXQvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIHNwbGl0QW5kSm9pbih0ZXh0OiBzdHJpbmcsIHNlcGFyYXRvcjogc3RyaW5nKTogW3N0cmluZywgc3RyaW5nXSB7XG4gIGNvbnN0IFtmaXJzdCwgLi4ucmVzdF0gPSB0ZXh0LnNwbGl0KHNlcGFyYXRvcilcblxuICBjb25zdCBqb2luID0gcmVzdC5qb2luKHNlcGFyYXRvcilcblxuICByZXR1cm4gW2ZpcnN0LCBqb2luXVxufSJdLCJuYW1lcyI6WyJzcGxpdEFuZEpvaW4iLCJ0ZXh0Iiwic2VwYXJhdG9yIiwiZmlyc3QiLCJyZXN0Iiwic3BsaXQiLCJqb2luIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/libs/split/index.ts\n")},"./src/scripts/service_worker/index.ts":(module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _libs_split__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/libs/split */ "./src/libs/split/index.ts");\n\n\nself.addEventListener("install", ()=>{\n    /**\n   * Auto-activate as the update was already accepted\n   */ self.skipWaiting();\n});\n/**\n * Only cache on production\n */ if (false) {} else {\n    self.addEventListener("fetch", (event)=>{\n        const url = new URL(event.request.url);\n        console.log("Service worker fetch", url.href);\n        if (url.pathname === "/manifest.json") {\n            event.respondWith((async ()=>{\n                const [hash, href] = (0,_libs_split__WEBPACK_IMPORTED_MODULE_0__.splitAndJoin)(url.hash.slice(1), "@");\n                const manifest = await fetch(new URL("/manifest.json", href)).then((r)=>r.json());\n                manifest.scope = "".concat(location.origin, "/?x=123");\n                manifest.start_url = "".concat(location.origin, "/?x=123#").concat(hash, "@").concat(href);\n                const headers = {\n                    "Content-Type": "application/json"\n                };\n                return new Response(JSON.stringify(manifest), {\n                    status: 200,\n                    statusText: "OK",\n                    headers\n                });\n            })());\n        }\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NyaXB0cy9zZXJ2aWNlX3dvcmtlci9pbmRleC50cyIsIm1hcHBpbmdzIjoiOztBQUEyQztBQUNHO0FBSTlDRSxLQUFLQyxnQkFBZ0IsQ0FBQyxXQUFXO0lBQy9COztHQUVDLEdBQ0RELEtBQUtFLFdBQVc7QUFDbEI7QUFPQTs7Q0FFQyxHQUNELElBQUlDLEtBQXFDLEVBQUUsRUF5RTFDLE1BRUk7SUFFSEgsS0FBS0MsZ0JBQWdCLENBQUMsU0FBUyxDQUFDTztRQUM5QixNQUFNSSxNQUFNLElBQUlDLElBQUlMLE1BQU1NLE9BQU8sQ0FBQ0YsR0FBRztRQUVyQ2EsUUFBUUMsR0FBRyxDQUFDLHdCQUF3QmQsSUFBSWUsSUFBSTtRQUU1QyxJQUFJZixJQUFJRyxRQUFRLEtBQUssa0JBQWtCO1lBQ3JDUCxNQUFNVSxXQUFXLENBQUMsQ0FBQztnQkFDakIsTUFBTSxDQUFDVSxNQUFNRCxLQUFLLEdBQUc3Qix5REFBWUEsQ0FBQ2MsSUFBSWdCLElBQUksQ0FBQ0MsS0FBSyxDQUFDLElBQUk7Z0JBRXJELE1BQU1aLFdBQVcsTUFBTWEsTUFBTSxJQUFJakIsSUFBSSxrQkFBa0JjLE9BQU9JLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsSUFBSTtnQkFFOUVoQixTQUFTaUIsS0FBSyxHQUFHLEdBQW1CLE9BQWhCQyxTQUFTQyxNQUFNLEVBQUM7Z0JBRXBDbkIsU0FBU29CLFNBQVMsR0FBRyxHQUE2QlQsT0FBMUJPLFNBQVNDLE1BQU0sRUFBQyxZQUFrQlQsT0FBUkMsTUFBSyxLQUFRLE9BQUxEO2dCQUUxRCxNQUFNSCxVQUFVO29CQUFFLGdCQUFnQjtnQkFBbUI7Z0JBRXJELE9BQU8sSUFBSUwsU0FBU0MsS0FBS0MsU0FBUyxDQUFDSixXQUFXO29CQUM1Q0ssUUFBUTtvQkFDUkMsWUFBWTtvQkFDWkM7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7QUFFRiIsInNvdXJjZXMiOlsiL1VzZXJzL2h1Z28vTG9jYWwvVHJhdmFpbC9odHRwc2VjL3NyYy9zY3JpcHRzL3NlcnZpY2Vfd29ya2VyL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNwbGl0QW5kSm9pbiB9IGZyb20gXCJAL2xpYnMvc3BsaXRcIlxuaW1wb3J0IHsgSW1tdXRhYmxlIH0gZnJvbSBcIkBoYXphZTQxL2ltbXV0YWJsZVwiXG5cbmRlY2xhcmUgY29uc3Qgc2VsZjogU2VydmljZVdvcmtlckdsb2JhbFNjb3BlXG5cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcImluc3RhbGxcIiwgKCkgPT4ge1xuICAvKipcbiAgICogQXV0by1hY3RpdmF0ZSBhcyB0aGUgdXBkYXRlIHdhcyBhbHJlYWR5IGFjY2VwdGVkXG4gICAqL1xuICBzZWxmLnNraXBXYWl0aW5nKClcbn0pXG5cbi8qKlxuICogRGVjbGFyZSBnbG9iYWwgdGVtcGxhdGVcbiAqL1xuZGVjbGFyZSBjb25zdCBGSUxFUzogW3N0cmluZywgc3RyaW5nXVtdXG5cbi8qKlxuICogT25seSBjYWNoZSBvbiBwcm9kdWN0aW9uXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgY29uc3QgY2FjaGUgPSBuZXcgSW1tdXRhYmxlLkNhY2hlKG5ldyBNYXAoRklMRVMpKVxuXG4gIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcImFjdGl2YXRlXCIsIChldmVudCkgPT4ge1xuICAgIC8qKlxuICAgICAqIFVuY2FjaGUgcHJldmlvdXMgdmVyc2lvblxuICAgICAqL1xuICAgIGV2ZW50LndhaXRVbnRpbChjYWNoZS51bmNhY2hlKCkpXG5cbiAgICAvKipcbiAgICAgKiBQcmVjYWNoZSBjdXJyZW50IHZlcnNpb25cbiAgICAgKi9cbiAgICBldmVudC53YWl0VW50aWwoY2FjaGUucHJlY2FjaGUoKSlcbiAgfSlcblxuICAvKipcbiAgICogUmVzcG9uZCB3aXRoIGNhY2hlXG4gICAqL1xuICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJmZXRjaFwiLCAoZXZlbnQpID0+IHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGV2ZW50LnJlcXVlc3QudXJsKVxuXG4gICAgaWYgKHVybC5wYXRobmFtZSAhPT0gXCIvbWFuaWZlc3QuanNvblwiKVxuICAgICAgcmV0dXJuIGNhY2hlLmhhbmRsZShldmVudClcblxuICAgIGNvbnN0IG1hbmlmZXN0ID0ge1xuICAgICAgXCIkc2NoZW1hXCI6IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL1NjaGVtYVN0b3JlL3NjaGVtYXN0b3JlL21hc3Rlci9zcmMvc2NoZW1hcy9qc29uL3dlYi1tYW5pZmVzdC5qc29uXCIsXG4gICAgICBcImlkXCI6IFwiNjY0NDZiYmUtYjY3Zi00ZWY2LWI0MmItNGRjMGJhMmVlNjZjXCIsXG4gICAgICBcIm5hbWVcIjogXCJCcnVtZSBXYWxsZXRcIixcbiAgICAgIFwidmVyc2lvblwiOiBcIlZFUlNJT05cIixcbiAgICAgIFwic2hvcnRfbmFtZVwiOiBcIkJydW1lIFdhbGxldFwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBwcml2YXRlIHdhbGxldFwiLFxuICAgICAgXCJzdGFydF91cmxcIjogXCIvXCIsXG4gICAgICBcImRpc3BsYXlcIjogXCJzdGFuZGFsb25lXCIsXG4gICAgICBcInRoZW1lX2NvbG9yXCI6IFwiI2ZmZmZmZlwiLFxuICAgICAgXCJiYWNrZ3JvdW5kX2NvbG9yXCI6IFwiI2ZmZmZmZlwiLFxuICAgICAgXCJsYW5nXCI6IFwiZW5cIixcbiAgICAgIFwiZGlyXCI6IFwibHRyXCIsXG4gICAgICBcIm9yaWVudGF0aW9uXCI6IFwiYW55XCIsXG4gICAgICBcImNhdGVnb3JpZXNcIjogW1xuICAgICAgICBcImZpbmFuY2VcIixcbiAgICAgICAgXCJzb2NpYWxcIixcbiAgICAgICAgXCJlbnRlcnRhaW5tZW50XCJcbiAgICAgIF0sXG4gICAgICBcImxhdW5jaF9oYW5kbGVyXCI6IHtcbiAgICAgICAgXCJjbGllbnRfbW9kZVwiOiBcImF1dG9cIlxuICAgICAgfSxcbiAgICAgIFwiaWNvbnNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJzcmNcIjogXCIvbWFza2ljb24ucG5nXCIsXG4gICAgICAgICAgXCJzaXplc1wiOiBcIjUxMng1MTJcIixcbiAgICAgICAgICBcInR5cGVcIjogXCJpbWFnZS9wbmdcIixcbiAgICAgICAgICBcInB1cnBvc2VcIjogXCJtYXNrYWJsZVwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcInNyY1wiOiBcIi9mYXZpY29uLnBuZ1wiLFxuICAgICAgICAgIFwic2l6ZXNcIjogXCI1MTJ4NTEyXCIsXG4gICAgICAgICAgXCJ0eXBlXCI6IFwiaW1hZ2UvcG5nXCIsXG4gICAgICAgICAgXCJwdXJwb3NlXCI6IFwiYW55XCJcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIFwic2hvcnRjdXRzXCI6IFtdLFxuICAgICAgXCJzY3JlZW5zaG90c1wiOiBbXVxuICAgIH1cblxuICAgIGV2ZW50LnJlc3BvbmRXaXRoKG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShtYW5pZmVzdCksIHtcbiAgICAgIHN0YXR1czogMjAwLFxuICAgICAgc3RhdHVzVGV4dDogXCJPS1wiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgXCJDYWNoZS1Db250cm9sXCI6IFwicHVibGljLCBtYXgtYWdlPTMxNTM2MDAwLCBpbW11dGFibGVcIlxuICAgICAgfVxuICAgIH0pKVxuICB9KVxufVxuXG5lbHNlIHtcblxuICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJmZXRjaFwiLCAoZXZlbnQpID0+IHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGV2ZW50LnJlcXVlc3QudXJsKVxuXG4gICAgY29uc29sZS5sb2coXCJTZXJ2aWNlIHdvcmtlciBmZXRjaFwiLCB1cmwuaHJlZilcblxuICAgIGlmICh1cmwucGF0aG5hbWUgPT09IFwiL21hbmlmZXN0Lmpzb25cIikge1xuICAgICAgZXZlbnQucmVzcG9uZFdpdGgoKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgW2hhc2gsIGhyZWZdID0gc3BsaXRBbmRKb2luKHVybC5oYXNoLnNsaWNlKDEpLCBcIkBcIilcblxuICAgICAgICBjb25zdCBtYW5pZmVzdCA9IGF3YWl0IGZldGNoKG5ldyBVUkwoXCIvbWFuaWZlc3QuanNvblwiLCBocmVmKSkudGhlbihyID0+IHIuanNvbigpKVxuXG4gICAgICAgIG1hbmlmZXN0LnNjb3BlID0gYCR7bG9jYXRpb24ub3JpZ2lufS8/eD0xMjNgXG5cbiAgICAgICAgbWFuaWZlc3Quc3RhcnRfdXJsID0gYCR7bG9jYXRpb24ub3JpZ2lufS8/eD0xMjMjJHtoYXNofUAke2hyZWZ9YFxuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH1cblxuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KG1hbmlmZXN0KSwge1xuICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IFwiT0tcIixcbiAgICAgICAgICBoZWFkZXJzXG4gICAgICAgIH0pXG4gICAgICB9KSgpKVxuICAgIH1cbiAgfSlcblxufSJdLCJuYW1lcyI6WyJzcGxpdEFuZEpvaW4iLCJJbW11dGFibGUiLCJzZWxmIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNraXBXYWl0aW5nIiwicHJvY2VzcyIsImNhY2hlIiwiQ2FjaGUiLCJNYXAiLCJGSUxFUyIsImV2ZW50Iiwid2FpdFVudGlsIiwidW5jYWNoZSIsInByZWNhY2hlIiwidXJsIiwiVVJMIiwicmVxdWVzdCIsInBhdGhuYW1lIiwiaGFuZGxlIiwibWFuaWZlc3QiLCJyZXNwb25kV2l0aCIsIlJlc3BvbnNlIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJoZWFkZXJzIiwiY29uc29sZSIsImxvZyIsImhyZWYiLCJoYXNoIiwic2xpY2UiLCJmZXRjaCIsInRoZW4iLCJyIiwianNvbiIsInNjb3BlIiwibG9jYXRpb24iLCJvcmlnaW4iLCJzdGFydF91cmwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/scripts/service_worker/index.ts\n')}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n){if(void 0!==n.error)throw n.error;return n.exports}var r=__webpack_module_cache__[e]={id:e,exports:{}};try{var t={id:e,module:r,factory:__webpack_modules__[e],require:__webpack_require__};__webpack_require__.i.forEach(function(e){e(t)}),r=t.module,t.factory.call(r.exports,r,r.exports,t.require)}catch(e){throw r.error=e,e}return r.exports}__webpack_require__.m=__webpack_modules__,__webpack_require__.c=__webpack_module_cache__,__webpack_require__.i=[],(()=>{__webpack_require__.d=(e,n)=>{for(var r in n)__webpack_require__.o(n,r)&&!__webpack_require__.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:n[r]})}})(),(()=>{__webpack_require__.hu=e=>""+e+"."+__webpack_require__.h()+".hot-update.js"})(),(()=>{__webpack_require__.hmrF=()=>"main."+__webpack_require__.h()+".hot-update.json"})(),(()=>{__webpack_require__.h=()=>"6d535d8f09c8a8b3a755"})(),(()=>{__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||Function("return this")()}catch(e){if("object"==typeof window)return window}}()})(),(()=>{__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n)})(),(()=>{__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}})(),(()=>{var e,n,r,t={},i=__webpack_require__.c,o=[],c=[],a="idle",l=0,s=[];function d(n,r){var t=i[r];if(!t)return n;var c=function(c){if(t.hot.active){if(i[c]){var a=i[c].parents;-1===a.indexOf(r)&&a.push(r)}else o=[r],e=c;-1===t.children.indexOf(c)&&t.children.push(c)}else console.warn("[HMR] unexpected require("+c+") from disposed module "+r),o=[];return n(c)},a=function(e){return{configurable:!0,enumerable:!0,get:function(){return n[e]},set:function(r){n[e]=r}}};for(var l in n)Object.prototype.hasOwnProperty.call(n,l)&&"e"!==l&&Object.defineProperty(c,l,a(l));return c.e=function(e,r){return h(n.e(e,r))},c}function u(i,l){var s=e!==i,d={_acceptedDependencies:{},_acceptedErrorHandlers:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_selfInvalidated:!1,_disposeHandlers:[],_main:s,_requireSelf:function(){o=l.parents.slice(),e=s?void 0:i,__webpack_require__(i)},active:!0,accept:function(e,n,r){if(void 0===e)d._selfAccepted=!0;else if("function"==typeof e)d._selfAccepted=e;else if("object"==typeof e&&null!==e)for(var t=0;t<e.length;t++)d._acceptedDependencies[e[t]]=n||function(){},d._acceptedErrorHandlers[e[t]]=r;else d._acceptedDependencies[e]=n||function(){},d._acceptedErrorHandlers[e]=r},decline:function(e){if(void 0===e)d._selfDeclined=!0;else if("object"==typeof e&&null!==e)for(var n=0;n<e.length;n++)d._declinedDependencies[e[n]]=!0;else d._declinedDependencies[e]=!0},dispose:function(e){d._disposeHandlers.push(e)},addDisposeHandler:function(e){d._disposeHandlers.push(e)},removeDisposeHandler:function(e){var n=d._disposeHandlers.indexOf(e);n>=0&&d._disposeHandlers.splice(n,1)},invalidate:function(){switch(this._selfInvalidated=!0,a){case"idle":n=[],Object.keys(__webpack_require__.hmrI).forEach(function(e){__webpack_require__.hmrI[e](i,n)}),p("ready");break;case"ready":Object.keys(__webpack_require__.hmrI).forEach(function(e){__webpack_require__.hmrI[e](i,n)});break;case"prepare":case"check":case"dispose":case"apply":(r=r||[]).push(i)}},check:g,apply:b,status:function(e){if(!e)return a;c.push(e)},addStatusHandler:function(e){c.push(e)},removeStatusHandler:function(e){var n=c.indexOf(e);n>=0&&c.splice(n,1)},data:t[i]};return e=void 0,d}function p(e){a=e;for(var n=[],r=0;r<c.length;r++)n[r]=c[r].call(null,e);return Promise.all(n).then(function(){})}function I(){0==--l&&p("ready").then(function(){if(0===l){var e=s;s=[];for(var n=0;n<e.length;n++)e[n]()}})}function h(e){switch(a){case"ready":p("prepare");case"prepare":return l++,e.then(I,I),e;default:return e}}function f(e){return 0===l?e():new Promise(function(n){s.push(function(){n(e())})})}function g(e){if("idle"!==a)throw Error("check() is only allowed in idle status");return p("check").then(__webpack_require__.hmrM).then(function(r){return r?p("prepare").then(function(){var t=[];return n=[],Promise.all(Object.keys(__webpack_require__.hmrC).reduce(function(e,i){return __webpack_require__.hmrC[i](r.c,r.r,r.m,e,n,t),e},[])).then(function(){return f(function(){return e?C(e):p("ready").then(function(){return t})})})}):p(m()?"ready":"idle").then(function(){return null})})}function b(e){return"ready"!==a?Promise.resolve().then(function(){throw Error("apply() is only allowed in ready status (state: "+a+")")}):C(e)}function C(e){e=e||{},m();var t,i=n.map(function(n){return n(e)});n=void 0;var o=i.map(function(e){return e.error}).filter(Boolean);if(o.length>0)return p("abort").then(function(){throw o[0]});var c=p("dispose");i.forEach(function(e){e.dispose&&e.dispose()});var a=p("apply"),l=function(e){t||(t=e)},s=[];return i.forEach(function(e){if(e.apply){var n=e.apply(l);if(n)for(var r=0;r<n.length;r++)s.push(n[r])}}),Promise.all([c,a]).then(function(){return t?p("fail").then(function(){throw t}):r?C(e).then(function(e){return s.forEach(function(n){0>e.indexOf(n)&&e.push(n)}),e}):p("idle").then(function(){return s})})}function m(){if(r)return n||(n=[]),Object.keys(__webpack_require__.hmrI).forEach(function(e){r.forEach(function(r){__webpack_require__.hmrI[e](r,n)})}),r=void 0,!0}__webpack_require__.hmrD=t,__webpack_require__.i.push(function(e){var n=e.module,r=d(e.require,e.id);n.hot=u(e.id,n),n.parents=o,n.children=[],o=[],e.require=r}),__webpack_require__.hmrC={},__webpack_require__.hmrI={}})(),(()=>{__webpack_require__.g.importScripts&&(e=__webpack_require__.g.location+"");var e,n=__webpack_require__.g.document;if(!e&&n&&(n.currentScript&&"SCRIPT"===n.currentScript.tagName.toUpperCase()&&(e=n.currentScript.src),!e)){var r=n.getElementsByTagName("script");if(r.length)for(var t=r.length-1;t>-1&&(!e||!/^http(s?):/.test(e));)e=r[t--].src}if(!e)throw Error("Automatic publicPath is not supported in this browser");__webpack_require__.p=e=e.replace(/^blob:/,"").replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/")})(),(()=>{__webpack_require__.i&&__webpack_require__.i.push(e=>{let n=e.factory;e.factory=(e,r,t)=>{let i="undefined"!=typeof self&&self.$RefreshInterceptModuleExecution$?self.$RefreshInterceptModuleExecution$(e.id):()=>{};try{n.call(this,e,r,t)}finally{i()}}})})(),"undefined"!=typeof self&&(self.$RefreshReg$=function(){},self.$RefreshSig$=function(){return function(e){return e}}),(()=>{var e,n,r,t,i=__webpack_require__.hmrS_importScripts=__webpack_require__.hmrS_importScripts||{main:1};function o(e,r){var i=!1;if(self.webpackHotUpdatemy_app=(e,o,c)=>{for(var a in o)__webpack_require__.o(o,a)&&(n[a]=o[a],r&&r.push(a));c&&t.push(c),i=!0},importScripts(__webpack_require__.p+__webpack_require__.hu(e)),!i)throw Error("Loading update chunk failed for unknown reason")}function c(o){function c(e){for(var n=[e],r={},t=n.map(function(e){return{chain:[e],id:e}});t.length>0;){var i=t.pop(),o=i.id,c=i.chain,l=__webpack_require__.c[o];if(l&&(!l.hot._selfAccepted||l.hot._selfInvalidated)){if(l.hot._selfDeclined)return{type:"self-declined",chain:c,moduleId:o};if(l.hot._main)return{type:"unaccepted",chain:c,moduleId:o};for(var s=0;s<l.parents.length;s++){var d=l.parents[s],u=__webpack_require__.c[d];if(u){if(u.hot._declinedDependencies[o])return{type:"declined",chain:c.concat([d]),moduleId:o,parentId:d};if(-1===n.indexOf(d)){if(u.hot._acceptedDependencies[o]){r[d]||(r[d]=[]),a(r[d],[o]);continue}delete r[d],n.push(d),t.push({chain:c.concat([d]),id:d})}}}}}return{type:"accepted",moduleId:e,outdatedModules:n,outdatedDependencies:r}}function a(e,n){for(var r=0;r<n.length;r++){var t=n[r];-1===e.indexOf(t)&&e.push(t)}}__webpack_require__.f&&delete __webpack_require__.f.importScriptsHmr,e=void 0;var l,s={},d=[],u={},p=function(e){console.warn("[HMR] unexpected require("+e.id+") to disposed module")};for(var I in n)if(__webpack_require__.o(n,I)){var h=n[I],f=h?c(I):{type:"disposed",moduleId:I},g=!1,b=!1,C=!1,m="";switch(f.chain&&(m="\nUpdate propagation: "+f.chain.join(" -> ")),f.type){case"self-declined":o.onDeclined&&o.onDeclined(f),o.ignoreDeclined||(g=Error("Aborted because of self decline: "+f.moduleId+m));break;case"declined":o.onDeclined&&o.onDeclined(f),o.ignoreDeclined||(g=Error("Aborted because of declined dependency: "+f.moduleId+" in "+f.parentId+m));break;case"unaccepted":o.onUnaccepted&&o.onUnaccepted(f),o.ignoreUnaccepted||(g=Error("Aborted because "+I+" is not accepted"+m));break;case"accepted":o.onAccepted&&o.onAccepted(f),b=!0;break;case"disposed":o.onDisposed&&o.onDisposed(f),C=!0;break;default:throw Error("Unexception type "+f.type)}if(g)return{error:g};if(b)for(I in u[I]=h,a(d,f.outdatedModules),f.outdatedDependencies)__webpack_require__.o(f.outdatedDependencies,I)&&(s[I]||(s[I]=[]),a(s[I],f.outdatedDependencies[I]));C&&(a(d,[f.moduleId]),u[I]=p)}n=void 0;for(var y=[],F=0;F<d.length;F++){var v=d[F],B=__webpack_require__.c[v];B&&(B.hot._selfAccepted||B.hot._main)&&u[v]!==p&&!B.hot._selfInvalidated&&y.push({module:v,require:B.hot._requireSelf,errorHandler:B.hot._selfAccepted})}return{dispose:function(){r.forEach(function(e){delete i[e]}),r=void 0;for(var e,n,t=d.slice();t.length>0;){var o=t.pop(),c=__webpack_require__.c[o];if(c){var a={},u=c.hot._disposeHandlers;for(F=0;F<u.length;F++)u[F].call(null,a);for(__webpack_require__.hmrD[o]=a,c.hot.active=!1,delete __webpack_require__.c[o],delete s[o],F=0;F<c.children.length;F++){var p=__webpack_require__.c[c.children[F]];p&&(e=p.parents.indexOf(o))>=0&&p.parents.splice(e,1)}}}for(var I in s)if(__webpack_require__.o(s,I)&&(c=__webpack_require__.c[I]))for(F=0,l=s[I];F<l.length;F++)n=l[F],(e=c.children.indexOf(n))>=0&&c.children.splice(e,1)},apply:function(e){for(var n in u)__webpack_require__.o(u,n)&&(__webpack_require__.m[n]=u[n]);for(var r=0;r<t.length;r++)t[r](__webpack_require__);for(var i in s)if(__webpack_require__.o(s,i)){var c=__webpack_require__.c[i];if(c){l=s[i];for(var a=[],p=[],I=[],h=0;h<l.length;h++){var f=l[h],g=c.hot._acceptedDependencies[f],b=c.hot._acceptedErrorHandlers[f];if(g){if(-1!==a.indexOf(g))continue;a.push(g),p.push(b),I.push(f)}}for(var C=0;C<a.length;C++)try{a[C].call(null,l)}catch(n){if("function"==typeof p[C])try{p[C](n,{moduleId:i,dependencyId:I[C]})}catch(r){o.onErrored&&o.onErrored({type:"accept-error-handler-errored",moduleId:i,dependencyId:I[C],error:r,originalError:n}),o.ignoreErrored||(e(r),e(n))}else o.onErrored&&o.onErrored({type:"accept-errored",moduleId:i,dependencyId:I[C],error:n}),o.ignoreErrored||e(n)}}}for(var m=0;m<y.length;m++){var F=y[m],v=F.module;try{F.require(v)}catch(n){if("function"==typeof F.errorHandler)try{F.errorHandler(n,{moduleId:v,module:__webpack_require__.c[v]})}catch(r){o.onErrored&&o.onErrored({type:"self-accept-error-handler-errored",moduleId:v,error:r,originalError:n}),o.ignoreErrored||(e(r),e(n))}else o.onErrored&&o.onErrored({type:"self-accept-errored",moduleId:v,error:n}),o.ignoreErrored||e(n)}}return d}}}__webpack_require__.hmrI.importScripts=function(e,i){n||(n={},t=[],r=[],i.push(c)),__webpack_require__.o(n,e)||(n[e]=__webpack_require__.m[e])},__webpack_require__.hmrC.importScripts=function(a,l,s,d,u,p){u.push(c),e={},r=l,n=s.reduce(function(e,n){return e[n]=!1,e},{}),t=[],a.forEach(function(n){__webpack_require__.o(i,n)&&void 0!==i[n]?(d.push(o(n,p)),e[n]=!0):e[n]=!1}),__webpack_require__.f&&(__webpack_require__.f.importScriptsHmr=function(n,r){e&&__webpack_require__.o(e,n)&&!e[n]&&(r.push(o(n)),e[n]=!0)})},__webpack_require__.hmrM=()=>{if("undefined"==typeof fetch)throw Error("No browser support: need fetch API");return fetch(__webpack_require__.p+__webpack_require__.hmrF()).then(e=>{if(404!==e.status){if(!e.ok)throw Error("Failed to fetch update manifest "+e.statusText);return e.json()}})}})();var __webpack_exports__=__webpack_require__("./src/scripts/service_worker/index.ts")})();